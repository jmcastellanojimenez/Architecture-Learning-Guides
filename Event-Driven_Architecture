## ðŸŽ¯ **Why Event-Driven?**

### âŒ **Problem: Monolith â†’ Microservices**
```
UserService â”€â”€HTTPâ”€â”€â†’ VideoService
    â†“ If VideoService fails...
ðŸ’¥ EVERYTHING CRASHES
```

### âœ… **Solution: Domain Events**
```
UserService â”€â”€eventâ”€â”€â†’ Message Broker â”€â”€â†’ VideoService
    â†“ If VideoService fails...
ðŸ˜Ž UserService keeps working
```

---

## ðŸ—ï¸ **Basic Architecture**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PRODUCER   â”‚â”€â”€â”€â–¶â”‚   BROKER    â”‚â”€â”€â”€â–¶â”‚  CONSUMER   â”‚
â”‚ (Microservice)â”‚   â”‚ (RabbitMQ/  â”‚   â”‚(Microservice)â”‚
â”‚             â”‚    â”‚  AWS SNS)   â”‚    â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ“¨ **Message vs Event**

### ðŸŽ­ **Event** = What happened in the domain
```json
{
  "type": "video_created",
  "data": { "videoId": "123", "userId": "456" }
}
```

### ðŸ“¦ **Message** = Container that transports the event
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ MESSAGE (unit in the queue)     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Headers: timestamp, etc     â”‚ â”‚
â”‚ â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â”‚
â”‚ â”‚ Body: EVENT (JSON)          â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ðŸ› ï¸ **Technology Solutions**

### ðŸ° **RabbitMQ (AMQP)**
```
Producer â†’ Exchange â†’ Queue â†’ Consumer
           (Router)  (Buffer)
```

**Exchange Types:**
- ðŸ”Š **Fanout**: Broadcast to all queues
- ðŸŽ¯ **Direct**: Exact routing key match
- ðŸ”— **Topic**: Routing key with wildcards (`video.*`)

### â˜ï¸ **AWS SNS + SQS**
```
Producer â†’ SNS Topic â†’ SQS Queue â†’ Consumer
           (Exchange)  (RabbitMQ Queue)
```

**Filtering:**
```json
{
  "MessageAttributes": {
    "event_type": "codelytv.video.1.event.video.published"
  }
}
```

### âš¡ **AWS EventBridge**
```
Producer â†’ EventBridge Bus â†’ Targets (Lambda/SQS/HTTP)
           (Managed Router)   (Multiple consumers)
```

**Event Patterns:**
```json
{
  "detail-type": ["payment"],
  "source": ["codelytv.video"]
}
```

**Advantages:**
- HTTP API Destinations (no consumer code needed)
- Schema registry support
- Cross-account events
- Built-in CloudWatch integration

### ðŸŒŠ **Kafka/Kinesis = Streaming**
```
âŒ NO for domain events
âœ… YES for data streams (logs, analytics)
```

---

## ðŸŽ¨ **Naming Conventions**

### ðŸ“‹ **Routing Key (AsyncAPI)**
```
codelytv.video.1.event.video.published
â”‚       â”‚     â”‚ â”‚     â”‚     â”‚
â”‚       â”‚     â”‚ â”‚     â”‚     â””â”€ Event (past tense)
â”‚       â”‚     â”‚ â”‚     â””â”€ Entity
â”‚       â”‚     â”‚ â””â”€ Type (event/command)
â”‚       â”‚     â””â”€ Version
â”‚       â””â”€ Bounded Context
â””â”€ Company
```

### ðŸ·ï¸ **Queue Name**
```
user.notification.notify_user_on_video_published
â”‚    â”‚           â”‚                â”‚
â”‚    â”‚           â”‚                â””â”€ Trigger event
â”‚    â”‚           â””â”€ Action
â”‚    â””â”€ Entity
â””â”€ Service
```

---

## âš ï¸ **Error Management**

### ðŸ”„ **Out-of-Order Events**

**Problem:**
```
Correct order: 1.conversation_created â†’ 2.message_sent
Received order: 1.message_sent â†’ 2.conversation_created âŒ
```

**Solutions:**
1. **Re-queue with counter**: ACK + manual requeue
2. **NACK**: Don't confirm, let broker retry

### ðŸ“¬ **Duplicate Events**

| Solution | What it does |
|----------|--------------|
| **Let it crash** ðŸ’¥ | Error â†’ Dead Letter Queue |
| **Deduplication** ðŸ“ | Store processed IDs in DB |
| **Idempotency** ðŸ‘ | Safe operations (UPSERT vs INSERT) |

### ðŸ’€ **Dead Letter Queues (DLQ)**

**All brokers support DLQ for failed messages:**

```yaml
RabbitMQ:
  - x-dead-letter-exchange: dlx-exchange
  - x-message-ttl: 300000

AWS SNS+SQS:
  - RedrivePolicy with maxReceiveCount
  - deadLetterTargetArn

AWS EventBridge:
  - DeadLetterConfig per target
  - SQS DLQ integration

Kafka:
  - Manual DLQ implementation
  - Separate error topics
```

### ðŸ” **Retry Strategies**

**Exponential Backoff Pattern:**
```
Attempt 1: Immediate
Attempt 2: 1 second
Attempt 3: 2 seconds  
Attempt 4: 4 seconds
â†’ DLQ after max attempts
```

**Implementation by Platform:**
```yaml
EventBridge:
  maximumRetryAttempts: 5
  maximumEventAge: 3600

SQS:
  visibilityTimeoutSeconds: 30
  maxReceiveCount: 3

RabbitMQ:
  x-max-retries: 3
  x-retry-delay: 30000
```

---

## ðŸ”§ **Circuit Breaker**

### ðŸš¨ **States**
```
CLOSED â”€â”€â”€â”€error rate highâ”€â”€â”€â”€â†’ OPEN
   â†‘                               â”‚
   â”‚                               â”‚ (timeout)
   â”‚                               â†“
   â””â”€â”€â”€â”€success rate OKâ”€â”€â”€â”€ HALF-OPEN
```

**Tools:**
- **Hystrix** (deprecated)
- **Resilience4j** â­ (recommended)
- **Service Mesh** (Istio, Linkerd)

---

## ðŸ“Š **Quick Comparison**

### ðŸŽ¯ **For Domain Events**
| Tool | Fan-out | DLQ | Complexity | Use Case |
|------|---------|-----|------------|----------|
| **RabbitMQ** | âœ… Easy | âœ… Built-in | ðŸŸ¡ Medium | Microservices |
| **SNS+SQS** | âœ… Easy | âœ… Built-in | ðŸŸ¡ Medium | AWS Cloud |
| **EventBridge** | âœ… Easy | âœ… SQS DLQ | ðŸŸ¢ Low | Serverless/HTTP |
| **Kafka** | ðŸŸ¡ Manual | ðŸ”´ Manual | ðŸ”´ High | Streaming |
| **Kinesis** | ðŸ”´ No | ðŸ”´ No | ðŸ”´ High | Big Data |

### âš¡ **Error Handling Capabilities**
| Tool | Retry | DLQ | Ordering | Deduplication |
|------|-------|-----|----------|---------------|
| **RabbitMQ** | âœ… Config | âœ… Native | âœ… Per queue | ðŸŸ¡ Plugin |
| **SNS+SQS** | âœ… Config | âœ… Native | ðŸŸ¡ FIFO only | âœ… Built-in |
| **EventBridge** | âœ… Config | âœ… SQS DLQ | ðŸ”´ No | ðŸ”´ Manual |
| **Kafka** | ðŸŸ¡ Manual | ðŸŸ¡ Manual | âœ… Per partition | âœ… Built-in |

---

## ðŸ† **Best Practices**

### âœ… **DO**
- **1 Exchange per microservice** (RabbitMQ)
- **1 Queue per use case + event**
- **Idempotent operations**
- **Descriptive names**
- **Versioning in routing keys**
- **Configure Dead Letter Queues**
- **Implement exponential backoff**
- **Monitor DLQ accumulation**

### âŒ **DON'T**
- **Don't use Kafka for simple events**
- **Don't ignore duplicates**
- **Don't use sync events for critical flows**
- **Don't forget DLQ configuration**
- **Don't retry indefinitely**

---

## ðŸš€ **Quick Start**

### 1ï¸âƒ£ **Design your event**
```json
{
  "data": {
    "id": "event-uuid",
    "type": "codelytv.video.1.event.video.published",
    "occurred_on": "2025-09-11T14:30:00Z",
    "attributes": {
      "id": "video-123",
      "user_id": "user-456"
    }
  }
}
```

### 2ï¸âƒ£ **Configure infrastructure**

**RabbitMQ:**
```yaml
Exchange: codelytv.video.topic
Queue: user.stats.increment_count_on_video_published
Binding: codelytv.video.*.event.video.published
DLQ: user.stats.increment_count_on_video_published.dlq
```

**AWS SNS+SQS:**
```yaml
SNS Topic: codelytv-video-events
SQS Queue: user-stats-queue
Filter Policy: {"event_type": ["video.published"]}
DLQ: user-stats-dlq
```

**AWS EventBridge:**
```yaml
Bus: codelytv-event-bus
Rule: video-events-rule
Event Pattern: {"detail-type": ["video"], "source": ["codelytv"]}
Targets: [CloudWatch, Lambda, HTTP API]
DLQ: eventbridge-dlq (SQS)
```

### 3ï¸âƒ£ **Implement idempotent consumer**
```java
@EventHandler("video.published")
public void handle(VideoPublishedEvent event) {
    try {
        // âœ… Idempotent operation
        userRepository.upsert(event.getUserId(), stats);
        
        // âœ… With deduplication
        if (!processedEvents.contains(event.getId())) {
            userStats.increment(event.getUserId());
            processedEvents.add(event.getId());
        }
        
    } catch (Exception e) {
        // Will retry automatically â†’ DLQ after max attempts
        log.error("Failed to process event: {}", event.getId(), e);
        throw e;
    }
}
```

### 4ï¸âƒ£ **Configure DLQ monitoring**
```yaml
CloudWatch Alarms:
- DLQ message count > 10
- Failed event processing rate
- Consumer lag monitoring
```

---

## ðŸŽ¯ **TL;DR**

**Event-Driven Architecture** = Decoupled microservices through asynchronous events

**Golden Rule**: An event represents something that **ALREADY HAPPENED** in your domain

**Error Management Trinity**: **DLQ + Retry + Idempotency** are mandatory

**Technology Choices**:
- **RabbitMQ**: Traditional microservices, full control
- **SNS+SQS**: AWS cloud, message queuing 
- **EventBridge**: Serverless, HTTP callbacks
- **Kafka**: High-volume streaming only

**To get started**: Choose your broker, design idempotent consumers, configure DLQ

**Avoid**: Kafka for simple events, non-idempotent operations, missing DLQ

---

*ðŸ“š Based on DDD principles, SOLID, and distributed systems best practices*
