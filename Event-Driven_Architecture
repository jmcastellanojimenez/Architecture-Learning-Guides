## 🎯 **Why Event-Driven?**

### ❌ **Problem: Monolith → Microservices**
```
UserService ──HTTP──→ VideoService
    ↓ If VideoService fails...
💥 EVERYTHING CRASHES
```

### ✅ **Solution: Domain Events**
```
UserService ──event──→ Message Broker ──→ VideoService
    ↓ If VideoService fails...
😎 UserService keeps working
```

---

## 🏗️ **Basic Architecture**

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│  PRODUCER   │───▶│   BROKER    │───▶│  CONSUMER   │
│ (Microservice)│   │ (RabbitMQ/  │   │(Microservice)│
│             │    │  AWS SNS)   │    │             │
└─────────────┘    └─────────────┘    └─────────────┘
```

---

## 📨 **Message vs Event**

### 🎭 **Event** = What happened in the domain
```json
{
  "type": "video_created",
  "data": { "videoId": "123", "userId": "456" }
}
```

### 📦 **Message** = Container that transports the event
```
┌─────────────────────────────────┐
│ MESSAGE (unit in the queue)     │
│ ┌─────────────────────────────┐ │
│ │ Headers: timestamp, etc     │ │
│ │─────────────────────────────│ │
│ │ Body: EVENT (JSON)          │ │
│ └─────────────────────────────┘ │
└─────────────────────────────────┘
```

---

## 🛠️ **Technology Solutions**

### 🐰 **RabbitMQ (AMQP)**
```
Producer → Exchange → Queue → Consumer
           (Router)  (Buffer)
```

**Exchange Types:**
- 🔊 **Fanout**: Broadcast to all queues
- 🎯 **Direct**: Exact routing key match
- 🔗 **Topic**: Routing key with wildcards (`video.*`)

### ☁️ **AWS SNS + SQS**
```
Producer → SNS Topic → SQS Queue → Consumer
           (Exchange)  (RabbitMQ Queue)
```

**Filtering:**
```json
{
  "MessageAttributes": {
    "event_type": "codelytv.video.1.event.video.published"
  }
}
```

### ⚡ **AWS EventBridge**
```
Producer → EventBridge Bus → Targets (Lambda/SQS/HTTP)
           (Managed Router)   (Multiple consumers)
```

**Event Patterns:**
```json
{
  "detail-type": ["payment"],
  "source": ["codelytv.video"]
}
```

**Advantages:**
- HTTP API Destinations (no consumer code needed)
- Schema registry support
- Cross-account events
- Built-in CloudWatch integration

### 🌊 **Kafka/Kinesis = Streaming**
```
❌ NO for domain events
✅ YES for data streams (logs, analytics)
```

---

## 🎨 **Naming Conventions**

### 📋 **Routing Key (AsyncAPI)**
```
codelytv.video.1.event.video.published
│       │     │ │     │     │
│       │     │ │     │     └─ Event (past tense)
│       │     │ │     └─ Entity
│       │     │ └─ Type (event/command)
│       │     └─ Version
│       └─ Bounded Context
└─ Company
```

### 🏷️ **Queue Name**
```
user.notification.notify_user_on_video_published
│    │           │                │
│    │           │                └─ Trigger event
│    │           └─ Action
│    └─ Entity
└─ Service
```

---

## ⚠️ **Error Management**

### 🔄 **Out-of-Order Events**

**Problem:**
```
Correct order: 1.conversation_created → 2.message_sent
Received order: 1.message_sent → 2.conversation_created ❌
```

**Solutions:**
1. **Re-queue with counter**: ACK + manual requeue
2. **NACK**: Don't confirm, let broker retry

### 📬 **Duplicate Events**

| Solution | What it does |
|----------|--------------|
| **Let it crash** 💥 | Error → Dead Letter Queue |
| **Deduplication** 📝 | Store processed IDs in DB |
| **Idempotency** 👐 | Safe operations (UPSERT vs INSERT) |

### 💀 **Dead Letter Queues (DLQ)**

**All brokers support DLQ for failed messages:**

```yaml
RabbitMQ:
  - x-dead-letter-exchange: dlx-exchange
  - x-message-ttl: 300000

AWS SNS+SQS:
  - RedrivePolicy with maxReceiveCount
  - deadLetterTargetArn

AWS EventBridge:
  - DeadLetterConfig per target
  - SQS DLQ integration

Kafka:
  - Manual DLQ implementation
  - Separate error topics
```

### 🔁 **Retry Strategies**

**Exponential Backoff Pattern:**
```
Attempt 1: Immediate
Attempt 2: 1 second
Attempt 3: 2 seconds  
Attempt 4: 4 seconds
→ DLQ after max attempts
```

**Implementation by Platform:**
```yaml
EventBridge:
  maximumRetryAttempts: 5
  maximumEventAge: 3600

SQS:
  visibilityTimeoutSeconds: 30
  maxReceiveCount: 3

RabbitMQ:
  x-max-retries: 3
  x-retry-delay: 30000
```

---

## 🔧 **Circuit Breaker**

### 🚨 **States**
```
CLOSED ────error rate high────→ OPEN
   ↑                               │
   │                               │ (timeout)
   │                               ↓
   └────success rate OK──── HALF-OPEN
```

**Tools:**
- **Hystrix** (deprecated)
- **Resilience4j** ⭐ (recommended)
- **Service Mesh** (Istio, Linkerd)

---

## 📊 **Quick Comparison**

### 🎯 **For Domain Events**
| Tool | Fan-out | DLQ | Complexity | Use Case |
|------|---------|-----|------------|----------|
| **RabbitMQ** | ✅ Easy | ✅ Built-in | 🟡 Medium | Microservices |
| **SNS+SQS** | ✅ Easy | ✅ Built-in | 🟡 Medium | AWS Cloud |
| **EventBridge** | ✅ Easy | ✅ SQS DLQ | 🟢 Low | Serverless/HTTP |
| **Kafka** | 🟡 Manual | 🔴 Manual | 🔴 High | Streaming |
| **Kinesis** | 🔴 No | 🔴 No | 🔴 High | Big Data |

### ⚡ **Error Handling Capabilities**
| Tool | Retry | DLQ | Ordering | Deduplication |
|------|-------|-----|----------|---------------|
| **RabbitMQ** | ✅ Config | ✅ Native | ✅ Per queue | 🟡 Plugin |
| **SNS+SQS** | ✅ Config | ✅ Native | 🟡 FIFO only | ✅ Built-in |
| **EventBridge** | ✅ Config | ✅ SQS DLQ | 🔴 No | 🔴 Manual |
| **Kafka** | 🟡 Manual | 🟡 Manual | ✅ Per partition | ✅ Built-in |

---

## 🏆 **Best Practices**

### ✅ **DO**
- **1 Exchange per microservice** (RabbitMQ)
- **1 Queue per use case + event**
- **Idempotent operations**
- **Descriptive names**
- **Versioning in routing keys**
- **Configure Dead Letter Queues**
- **Implement exponential backoff**
- **Monitor DLQ accumulation**

### ❌ **DON'T**
- **Don't use Kafka for simple events**
- **Don't ignore duplicates**
- **Don't use sync events for critical flows**
- **Don't forget DLQ configuration**
- **Don't retry indefinitely**

---

## 🚀 **Quick Start**

### 1️⃣ **Design your event**
```json
{
  "data": {
    "id": "event-uuid",
    "type": "codelytv.video.1.event.video.published",
    "occurred_on": "2025-09-11T14:30:00Z",
    "attributes": {
      "id": "video-123",
      "user_id": "user-456"
    }
  }
}
```

### 2️⃣ **Configure infrastructure**

**RabbitMQ:**
```yaml
Exchange: codelytv.video.topic
Queue: user.stats.increment_count_on_video_published
Binding: codelytv.video.*.event.video.published
DLQ: user.stats.increment_count_on_video_published.dlq
```

**AWS SNS+SQS:**
```yaml
SNS Topic: codelytv-video-events
SQS Queue: user-stats-queue
Filter Policy: {"event_type": ["video.published"]}
DLQ: user-stats-dlq
```

**AWS EventBridge:**
```yaml
Bus: codelytv-event-bus
Rule: video-events-rule
Event Pattern: {"detail-type": ["video"], "source": ["codelytv"]}
Targets: [CloudWatch, Lambda, HTTP API]
DLQ: eventbridge-dlq (SQS)
```

### 3️⃣ **Implement idempotent consumer**
```java
@EventHandler("video.published")
public void handle(VideoPublishedEvent event) {
    try {
        // ✅ Idempotent operation
        userRepository.upsert(event.getUserId(), stats);
        
        // ✅ With deduplication
        if (!processedEvents.contains(event.getId())) {
            userStats.increment(event.getUserId());
            processedEvents.add(event.getId());
        }
        
    } catch (Exception e) {
        // Will retry automatically → DLQ after max attempts
        log.error("Failed to process event: {}", event.getId(), e);
        throw e;
    }
}
```

### 4️⃣ **Configure DLQ monitoring**
```yaml
CloudWatch Alarms:
- DLQ message count > 10
- Failed event processing rate
- Consumer lag monitoring
```

---

## 🎯 **TL;DR**

**Event-Driven Architecture** = Decoupled microservices through asynchronous events

**Golden Rule**: An event represents something that **ALREADY HAPPENED** in your domain

**Error Management Trinity**: **DLQ + Retry + Idempotency** are mandatory

**Technology Choices**:
- **RabbitMQ**: Traditional microservices, full control
- **SNS+SQS**: AWS cloud, message queuing 
- **EventBridge**: Serverless, HTTP callbacks
- **Kafka**: High-volume streaming only

**To get started**: Choose your broker, design idempotent consumers, configure DLQ

**Avoid**: Kafka for simple events, non-idempotent operations, missing DLQ

---

*📚 Based on DDD principles, SOLID, and distributed systems best practices*
